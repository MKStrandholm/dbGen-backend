from connection import connect_to_db
from sql_parser import generate
import json
    
def compound_key_script(list_of_keys):
    """
        -Generate a query statement with the compound keys found in the script.
        -Based on the rules of a compound key, the code belows assumes there will 
        always be 2 values in the array.

        -Keyword arguments:
            list_of_keys    --    List of names of the keys.
        
        return    --    String representing the query statement.
    """
    
    return f"\n\tPRIMARY KEY({list_of_keys[0]},{list_of_keys[1]}),"

def foreign_key_script(list_of_keys,prefixes_dict):
    """
        -Generate a query statement with the foreign keys found in the script.

        -Keyword arguments:
            list_of_keys     --    List of names of the keys.
            prefixes_dict    --    Dictionary of table names and prefixes for references.
        
        return    --    String representing the query statement.
    """
    final_statement = ""
    for index in range(len(list_of_keys)):
        table_name = ""
        #Get the prefix name from the field that is included in the name of the field.
        table_prefix = list_of_keys[index].split("_")
        #Extract the prefix from the field to indentify relationship
        for name, field_prefix in prefixes_dict.items():
            if field_prefix == table_prefix[0]:
                table_name = name    
        final_statement += f"\n\tFOREIGN KEY ({list_of_keys[index]})\n\t\tREFERENCES {table_name} ({list_of_keys[index]}),"

    return final_statement


def populate_prefixes_table(prefixes_dict,names_of_tables_list):
    '''
        Create a table that will contain all the names and prefixes of script

        -Keyword arguments:
            prefixes_dict            --    Dictionary containing the prefixes of each table.
            names_of_tables_list     --    List containing the name of each table.
        
        return String containing the query script to insert the values into the table of prefixes.

    '''
    #Initial statement is already added to the final script.
    query_statement = ""
    for index in range(len(names_of_tables_list)):
        query_statement += f'''\nINSERT INTO prefixes (table_name, table_field_prefix, relationship_prefix) 
    VALUES ('{names_of_tables_list[index].lower()}','{prefixes_dict[f'{names_of_tables_list[index]}'].lower()}','{prefixes_dict[f'{names_of_tables_list[index]}']}');'''   
    return query_statement


def generate_script(tables_dictionary):
    '''
        Generate a postgreSQL script from the generation script extracted from the file

        Keyword Arguments:
        tables_dictionary       --      Dictionary containing the script from the file

        return String containing the complete query script that will generate the DB tables.

    '''
    main_script = "BEGIN;\n"
    prefixes_dict = {}
    names_of_tables = []
    #extract the list of names and prefixes to create references.
    for table in tables_dictionary:
        #save names and prefix in a dictionary
        prefixes_dict[f"{table['table_name']}"] = f"{table['table_prefix']}"
        names_of_tables.append(table['table_name'])

    #extract the required information to create a query script.
    for table in tables_dictionary:
        #First query statement.
        initial_query_statement = f"\nCREATE TABLE IF NOT EXISTS {table['table_name']}\n("

        #Declare the variables to be able to extract them from the inner loop, 
        #as well as resetting their values.
        field_statements = ""  
        final_table_query = ""
        primary_key_statement = ""

        #get the dictionary of Field objects from the table
        fields_list = table['table_fields']

        #if a primary key is found, the value will be 1, if a compound key is found, 
        # value will be 2
        primary_key_found = 0
        foreign_key_found = False
        compound_keys = []
        foreign_keys = []

        #loop through and add the fields to the query script
        for field in fields_list:
       
            field_script = ""
            #make the prefix part of the name for the field.
            new_field_name = f"{field['field_prefix']}_{field['field_name']}" 
            #replace the float value to REAL, as this is the type value for postgreSQL
            if "float" in field['field_type']:
                field['field_type'] = "REAL"
            # Convert ID fields to SERIAL type (provided they aren't UUID format or FKs) so they auto increment
            if field['field_name'] == 'ID' and not field['isForeign']:
                if field['field_type'] != 'uuid':
                    field['field_type'] = "INT GENERATED BY DEFAULT AS IDENTITY"
            # If the field is a FK id, we want to cast it to integer to match the datatypes from their own tables 
            # (so it's a serial-integer match vs a serial-char(6) which won't work)
            if field['field_name'] == 'ID' and field['isForeign']:
                field['field_type'] = "integer"
            #flags to find primary keys, compound keys and foreign keys.
            if field['isPrimary'] == True and field['isForeign'] == True:#compound key flag
                field_script = f"\n\t{new_field_name} {field['field_type'].upper()},"
                primary_key_found = 2
                compound_keys.append(new_field_name)
                foreign_keys.append(new_field_name)
            elif field['isPrimary'] == True and field['isForeign'] == False: #primary key flag
                field_script = f"\n\t{new_field_name} {field['field_type'].upper()},"
                primary_key_found = 1
                primary_key_statement = f"\n\tPRIMARY KEY ({new_field_name}),"
            elif field['isPrimary'] == False and field['isForeign'] == True: #Foreign Key flag
                field_script = f"\n\t{new_field_name} {field['field_type'].upper()},"
                foreign_key_found = True
                foreign_keys.append(new_field_name)
            else:
                field_script = f"\n\t{new_field_name} {field['field_type'].upper()},"
            field_statements += field_script

        #add fields statements to the main query statement
        final_table_query = initial_query_statement + field_statements

        #Append keys found at the end of the fields queries
        if primary_key_found == 2:
            final_table_query += compound_key_script(compound_keys)
            final_table_query += foreign_key_script(foreign_keys,prefixes_dict)
        if primary_key_found == 1:
            final_table_query += primary_key_statement
        if foreign_key_found:
            final_table_query += foreign_key_script(foreign_keys,prefixes_dict)

        #remove last comma
        l=len(final_table_query)
        clean_query_statements = final_table_query[:l-1]
        final_table_query = clean_query_statements
        #add closing parenthesis
        final_table_query += "\n);\n"
        #add table query to the main query.
        main_script += final_table_query
    
    #add prefixes table
    main_script += f'''\nCREATE TABLE IF NOT EXISTS prefixes\n(\n
        table_name VARCHAR(50),
        table_field_prefix VARCHAR(50),
        relationship_prefix VARCHAR(50)\n);\n'''
    #populate the prefixes table.
    main_script += populate_prefixes_table(prefixes_dict,names_of_tables)
    #closing statement for the whole query script.
    main_script += "\n\nEND;"
   
    return main_script

def return_script():
        #get JSON script extracted from the file. This will be used to create the DB
        json_script = generate("sample_script2.psql")
        #convert JSON script into a Python dictionary
        dictionary_of_tables = json.loads(json_script)

        #TESTING PRINTS BELOW
        print("================== ORIGINAL JSON SCRIPT BELOW ====================")
        print(json_script)
        print("================== MAIN POSTGRES SCRIPT BELOW ====================")
        main_script = generate_script(dictionary_of_tables)

        print(main_script)
        return main_script


conn = connect_to_db()
conn.set_session(readonly=False, autocommit=True)  
cur = conn.cursor()

try:
    #Create the tables in the DB if they do not exist, based on the script given.
    cur.execute(return_script())
    print("Database initalization successful!")
except (Exception) as error:
    print ("Error while fetching data from PostgreSQL:", error)
finally:
    if conn:
        cur.close()
        conn.close()          